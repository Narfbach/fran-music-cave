// Upload functionalityconst uploadSection = document.getElementById('uploadSection');const uploadToggle = document.getElementById('uploadToggle');const uploadClose = document.getElementById('uploadClose');const uploadForm = document.getElementById('uploadForm');const uploadSuccess = document.getElementById('uploadSuccess');// Auto-fill metadata when URL is enteredconst trackUrlInput = document.getElementById('trackUrl');const trackTitleInput = document.getElementById('trackTitle');const trackArtistInput = document.getElementById('trackArtist');let metadataTimeout;trackUrlInput.addEventListener('input', () => { clearTimeout(metadataTimeout); metadataTimeout = setTimeout(async () => { const url = trackUrlInput.value.trim(); if (!url) return; // Show loading state trackTitleInput.placeholder = 'Loading...'; trackArtistInput.placeholder = 'Loading...'; const metadata = await extractMetadata(url); if (metadata) { trackTitleInput.value = metadata.title; trackArtistInput.value = metadata.artist; trackTitleInput.placeholder = 'Track name'; trackArtistInput.placeholder = 'Artist name'; } else { trackTitleInput.placeholder = 'Track name'; trackArtistInput.placeholder = 'Artist name'; } }, 1000); // Wait 1 second after user stops typing});// Abrir modal de uploaduploadToggle.addEventListener('click', () => { // Check if user is logged in if (!window.currentUser) { alert('⚠️ Debes estar registrado para subir tracks.\n\nCrea tu cuenta gratis haciendo click en LOGIN y comparte tu música favorita con la comunidad.'); return; } uploadSection.classList.add('active'); document.body.style.overflow = 'hidden';});// Cerrar modaluploadClose.addEventListener('click', closeUploadModal);uploadSection.addEventListener('click', (e) => { if (e.target === uploadSection) { closeUploadModal(); }});function closeUploadModal() { uploadSection.classList.remove('active'); document.body.style.overflow = 'auto'; uploadForm.reset(); uploadForm.style.display = 'block'; uploadSuccess.classList.remove('active');}// Función para extraer metadata automáticamenteasync function extractMetadata(url) { try { // Spotify - use CORS proxy to fetch metadata if (url.includes('spotify.com')) { const match = url.match(/track\/([a-zA-Z0-9]+)/); if (match) { const trackId = match[1]; try { // Use allorigins.win as CORS proxy const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://open.spotify.com/track/${trackId}`)}`; const response = await fetch(proxyUrl); const data = await response.json(); if (data.contents) { const parser = new DOMParser(); const doc = parser.parseFromString(data.contents, 'text/html'); // Try og:title which usually has "Song · Artist" const ogTitle = doc.querySelector('meta[property="og:title"]')?.content; console.log('Spotify og:title:', ogTitle); if (ogTitle) { // Try to split by · (middle dot) const parts = ogTitle.split('·').map(p => p.trim()); if (parts.length >= 2) { return { title: parts[0], artist: parts[1] }; } } // Try title tag as fallback const titleTag = doc.querySelector('title')?.textContent; if (titleTag) { console.log('Spotify title tag:', titleTag); const parts = titleTag.split(' - ').map(p => p.trim()); if (parts.length >= 2) { return { title: parts[1], artist: parts[0] }; } } } } catch (error) { console.log('Failed to fetch via proxy:', error); } // Fallback to oEmbed (only has song name, no artist) try { const oEmbedUrl = `https://open.spotify.com/oembed?url=https://open.spotify.com/track/${trackId}`; const response = await fetch(oEmbedUrl); const data = await response.json(); return { title: data.title || '', artist: '' }; } catch (error) { console.log('oEmbed also failed:', error); } } } // YouTube - usar oEmbed API if (url.includes('youtube.com') || url.includes('youtu.be')) { let videoId; if (url.includes('youtu.be/')) { videoId = url.split('youtu.be/')[1].split('?')[0]; } else { const match = url.match(/[?&]v=([^&]+)/); videoId = match ? match[1] : null; } if (videoId) { const oEmbedUrl = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`; const response = await fetch(oEmbedUrl); const data = await response.json(); // YouTube title often in format: "Artist - Song Name" or "Song Name - Artist" const title = data.title; const dashMatch = title.match(/(.*?)\s*[-–—]\s*(.*)/); if (dashMatch) { return { title: dashMatch[2].trim(), artist: dashMatch[1].trim() }; } else { return { title: title, artist: data.author_name || '' }; } } } // SoundCloud - usar oEmbed API if (url.includes('soundcloud.com')) { const oEmbedUrl = `https://soundcloud.com/oembed?url=${encodeURIComponent(url)}&format=json`; const response = await fetch(oEmbedUrl); const data = await response.json(); // SoundCloud title often in format: "Artist - Song Name" const title = data.title; const dashMatch = title.match(/(.*?)\s*[-–—]\s*(.*)/); if (dashMatch) { return { artist: dashMatch[1].trim(), title: dashMatch[2].trim() }; } else { return { title: title, artist: data.author_name || '' }; } } } catch (error) { console.error('Error extracting metadata:', error); } return null;}// Función para detectar plataforma y convertir URLfunction processTrackUrl(url) { // Spotify if (url.includes('spotify.com')) { const match = url.match(/track\/([a-zA-Z0-9]+)/); if (match) { return { platform: 'spotify', embedUrl: `https://open.spotify.com/embed/track/${match[1]}` }; } } // YouTube if (url.includes('youtube.com') || url.includes('youtu.be')) { let videoId; if (url.includes('youtu.be/')) { videoId = url.split('youtu.be/')[1].split('?')[0]; } else { const match = url.match(/[?&]v=([^&]+)/); videoId = match ? match[1] : null; } if (videoId) { return { platform: 'youtube', embedUrl: `https://www.youtube.com/embed/${videoId}` }; } } // SoundCloud if (url.includes('soundcloud.com')) { return { platform: 'soundcloud', embedUrl: `https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true` }; } return null;}// Enviar formulariouploadForm.addEventListener('submit', async (e) => { e.preventDefault(); const trackUrl = document.getElementById('trackUrl').value.trim(); const trackTitle = document.getElementById('trackTitle').value.trim(); const trackArtist = document.getElementById('trackArtist').value.trim(); const submitterName = document.getElementById('submitterName').value.trim(); // Procesar URL const trackData = processTrackUrl(trackUrl); if (!trackData) { alert('Invalid URL. Please use Spotify, YouTube or SoundCloud links.'); return; } if (!window.chatDb) { alert('Firebase is not configured properly.'); return; } try { // Get current user info and admin status const userId = window.currentUser?.uid || null; const username = window.currentUser?.displayName || submitterName || 'Anonymous'; // Get user's admin status from Firestore let isAdmin = false; if (userId) { try { const userDoc = await window.chatGetDoc(window.chatDoc(window.chatDb, 'users', userId)); if (userDoc.exists()) { isAdmin = userDoc.data().isAdmin || false; } } catch (error) { console.error('Error getting user admin status:', error); } } // Guardar directamente en la colección "tracks" (publicación automática) await window.chatAddDoc(window.chatCollection(window.chatDb, 'tracks'), { title: trackTitle, artist: trackArtist, platform: trackData.platform, embedUrl: trackData.embedUrl, submittedBy: username, userId: userId, isAdmin: isAdmin, timestamp: window.chatServerTimestamp(), likes: 0 }); // Increment tracksSubmitted and diggerScore for the user if (userId) { const userRef = window.chatDoc(window.chatDb, 'users', userId); const userDoc = await window.chatGetDoc(userRef); if (userDoc.exists()) { const currentTracks = userDoc.data().tracksSubmitted || 0; const currentScore = userDoc.data().diggerScore || 0; await window.chatUpdateDoc(userRef, { tracksSubmitted: currentTracks + 1, diggerScore: currentScore + 10 // +10 points per track }); } } // Mostrar mensaje de éxito uploadForm.style.display = 'none'; uploadSuccess.classList.add('active'); // Cerrar automáticamente después de 2 segundos setTimeout(() => { closeUploadModal(); }, 2000); } catch (error) { console.error('Error submitting track:', error); alert('Error submitting track. Please try again.'); }});